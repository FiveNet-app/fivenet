<script lang="ts" setup>
import { format, addDays, subDays } from 'date-fns';
import { z } from 'zod';
import DataErrorBlock from '~/components/partials/data/DataErrorBlock.vue';
import * as googleProtobufTimestamp from '~~/gen/ts/google/protobuf/timestamp';
import { TimeclockEntry } from '~~/gen/ts/resources/jobs/timeclock';
import TimeclockStatsBlock from '~/components/jobs/timeclock/TimeclockStatsBlock.vue';
import { getWeekNumber } from '~/utils/time';
import type { ListTimeclockRequest, ListTimeclockResponse } from '~~/gen/ts/services/jobs/timeclock';
import DatePickerClient from '~/components/partials/DatePicker.client.vue';
import { useCompletorStore } from '~/store/completor';
import type { Colleague } from '~~/gen/ts/resources/jobs/colleagues';
import Pagination from '~/components/partials/Pagination.vue';
import ProfilePictureImg from '~/components/partials/citizens/ProfilePictureImg.vue';
import ColleagueInfoPopover from '../colleagues/ColleagueInfoPopover.vue';

const { $grpc } = useNuxtApp();

const { t } = useI18n();

const completorStore = useCompletorStore();

const canAccessAll = attr('JobsTimeclockService.ListTimeclock', 'Access', 'All');

const now = new Date();
const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
const futureToday = addDays(today, 1);

const schema = z.object({
    users: z.custom<Colleague>().array().max(5).optional(),
    from: z.date(),
    to: z.date().optional(),
    perDay: z.boolean(),
});

type Schema = z.output<typeof schema>;

const query = reactive<Schema>({
    users: [],
    from: new Date(),
    to: subDays(now, 1),
    perDay: true,
});

const futureDay = computed(() => addDays(query.from, 1));
const previousDay = computed(() => subDays(query.from, 1));

const usersLoading = ref(false);

const page = ref(1);
const offset = computed(() => (data.value?.pagination?.pageSize ? data.value?.pagination?.pageSize * (page.value - 1) : 0));

const {
    data,
    pending: loading,
    refresh,
    error,
} = useLazyAsyncData(
    `jobs-timeclock-${query.from}-${query.to}-${query.perDay}-${query.users?.map((u) => u.userId)}-${page.value}`,
    () => listTimeclockEntries(),
);

const perDayView = computed(() => !canAccessAll || !(query.users !== undefined && query.users.length > 0));

async function listTimeclockEntries(): Promise<ListTimeclockResponse> {
    try {
        const req: ListTimeclockRequest = {
            pagination: {
                offset: offset.value,
            },
            userIds: query.users?.map((u) => u.userId) ?? [],
        };

        req.from = {
            timestamp: googleProtobufTimestamp.Timestamp.fromDate(query.from),
        };

        req.perDay = perDayView.value;
        if (req.perDay) {
            req.to = {
                timestamp: googleProtobufTimestamp.Timestamp.fromDate(subDays(query.from, 1)),
            };
        } else if (query.to) {
            req.to = {
                timestamp: googleProtobufTimestamp.Timestamp.fromDate(query.to),
            };
        }

        const call = $grpc.getJobsTimeclockClient().listTimeclock(req);
        const { response } = await call;

        return response;
    } catch (e) {
        $grpc.handleError(e as RpcError);
        throw e;
    }
}

type GroupTimeClockEntry = { date?: Date; entry: TimeclockEntry }[];

const grouped = computed(() => {
    const groups: GroupTimeClockEntry = [];

    data.value?.entries.forEach((e) => {
        const date = toDate(e.date);
        const idx = groups.findIndex((g) => g.date === date);
        if (idx === -1) {
            groups.push({
                date: date,
                entry: e,
            });
        } else {
            groups.push({
                date: date,
                entry: e,
            });
        }
    });

    return groups;
});

watch(offset, async () => refresh());
watchDebounced(query, async () => refresh(), { debounce: 200, maxWait: 1250 });

function dayForward(): void {
    query.from = addDays(query.from, 1);
    query.to = addDays(query.to ?? new Date(), 1);
}

function dayBackwards(): void {
    query.from = subDays(query.from, 1);
    query.to = subDays(query.to ?? new Date(), 1);
}

// Update date to something reasonable when per day view is actived
watch(perDayView, () => {
    if (canAccessAll && !perDayView.value) {
        const from = query.from;
        const to = subDays(query.to ?? new Date(), 7);
        query.from = to;
        query.to = from;
    }
});

const columns = computed(() =>
    [
        !perDayView.value
            ? {
                  key: 'date',
                  label: t('common.date'),
              }
            : undefined,
        {
            key: 'name',
            label: t('common.name'),
        },
        {
            key: 'time',
            label: t('common.time'),
        },
    ].flatMap((item) => (item !== undefined ? [item] : [])),
);

const input = ref<{ input: HTMLInputElement }>();
</script>

<template>
    <UDashboardToolbar>
        <template #default>
            <UForm :schema="schema" :state="query" class="flex-1" @submit="refresh()">
                <div class="flex w-full flex-col gap-2">
                    <div class="flex w-full flex-col">
                        <UButton
                            v-if="can('JobsTimeclockService.ListInactiveEmployees')"
                            :to="{ name: 'jobs-timeclock-inactive' }"
                            class="mb-2 place-self-end"
                            trailing-icon="i-mdi-arrow-right"
                        >
                            {{ $t('common.inactive_colleagues') }}
                        </UButton>

                        <div class="flex flex-row gap-2">
                            <UFormGroup v-if="canAccessAll" name="users" :label="$t('common.search')" class="flex-1">
                                <USelectMenu
                                    ref="input"
                                    v-model="query.users"
                                    multiple
                                    :searchable="
                                        async (query: string) => {
                                            usersLoading = true;
                                            const colleagues = await completorStore.listColleagues({
                                                search: query,
                                            });
                                            usersLoading = false;
                                            return colleagues;
                                        }
                                    "
                                    :search-attributes="['firstname', 'lastname']"
                                    block
                                    :placeholder="$t('common.colleague', 2)"
                                    trailing
                                    by="userId"
                                    :searchable-placeholder="$t('common.search_field')"
                                    @focusin="focusTablet(true)"
                                    @focusout="focusTablet(false)"
                                >
                                    <template #label>
                                        <template v-if="query.users?.length">
                                            {{ usersToLabel(query.users) }}
                                        </template>
                                    </template>
                                    <template #option="{ option: user }">
                                        {{ `${user?.firstname} ${user?.lastname} (${user?.dateofbirth})` }}
                                    </template>
                                    <template #option-empty="{ query: search }">
                                        <q>{{ search }}</q> {{ $t('common.query_not_found') }}
                                    </template>
                                    <template #empty> {{ $t('common.not_found', [$t('common.creator', 2)]) }} </template>
                                </USelectMenu>
                            </UFormGroup>

                            <UFormGroup
                                name="from"
                                :label="perDayView ? $t('common.date') : `${$t('common.time_range')} ${$t('common.from')}`"
                                class="flex-1"
                            >
                                <UPopover :popper="{ placement: 'bottom-start' }">
                                    <UButton
                                        variant="outline"
                                        color="gray"
                                        block
                                        icon="i-mdi-calendar-month"
                                        :label="query.from ? format(query.from, 'dd.MM.yyyy') : 'dd.mm.yyyy'"
                                    />

                                    <template #panel="{ close }">
                                        <DatePickerClient v-model="query.from" @close="close" />
                                    </template>
                                </UPopover>
                            </UFormGroup>

                            <UFormGroup
                                v-if="!perDayView"
                                name="to"
                                :label="`${$t('common.time_range')} ${$t('common.to')}`"
                                class="flex-1"
                            >
                                <UPopover :popper="{ placement: 'bottom-start' }">
                                    <UButton
                                        variant="outline"
                                        color="gray"
                                        block
                                        icon="i-mdi-calendar-month"
                                        :label="query.to ? format(query.to, 'dd.MM.yyyy') : 'dd.mm.yyyy'"
                                    />

                                    <template #panel="{ close }">
                                        <DatePickerClient v-model="query.to" @close="close" />
                                    </template>
                                </UPopover>
                            </UFormGroup>
                        </div>
                    </div>

                    <div v-if="perDayView" class="flex flex-row gap-2">
                        <UButton
                            block
                            class="flex-1"
                            :disabled="futureToday.getTime() <= futureDay.getTime()"
                            icon="i-mdi-chevron-left"
                            @click="dayForward()"
                        >
                            {{ $t('common.forward') }} - {{ $d(futureDay, 'date') }}
                        </UButton>

                        <UButton
                            disabled
                            icon="i-mdi-calendar"
                            class="flex flex-initial cursor-pointer flex-col place-content-end items-center"
                        >
                            <span>
                                {{ $d(query.from, 'date') }}
                            </span>
                            <span>{{ $t('common.calendar_week') }}: {{ getWeekNumber(query.from) }}</span>
                        </UButton>

                        <UButton class="flex-1" block trailing-icon="i-mdi-chevron-right" @click="dayBackwards()">
                            {{ $d(previousDay, 'date') }} - {{ $t('common.previous') }}
                        </UButton>
                    </div>
                </div>
            </UForm>
        </template>
    </UDashboardToolbar>

    <DataErrorBlock v-if="error" :title="$t('common.unable_to_load', [$t('common.entry', 2)])" :retry="refresh" />
    <template v-else>
        <UTable
            :loading="loading"
            :columns="columns"
            :rows="grouped"
            :empty-state="{
                icon: 'i-mdi-timeline-clock',
                label: $t('common.not_found', [$t('common.entry', 2)]),
            }"
        >
            <template #date-data="{ row: entry }">
                <div class="inline-flex items-center text-gray-900 dark:text-white">
                    {{ $d(entry.date, 'date') }}
                </div>
            </template>

            <template #name-data="{ row: entry }">
                <div class="inline-flex items-center gap-1">
                    <ProfilePictureImg
                        :src="entry.entry.user?.avatar?.url"
                        :name="`${entry.entry.user?.firstname} ${entry.entry.user?.lastname}`"
                        size="sm"
                    />

                    <ColleagueInfoPopover :user="entry.entry.user" />
                </div>
            </template>

            <template #time-data="{ row: entry }">
                <div class="text-right">
                    {{
                        entry.entry.spentTime > 0
                            ? fromSecondsToFormattedDuration(
                                  parseFloat(((Math.round(entry.entry.spentTime * 100) / 100) * 60 * 60).toPrecision(2)),
                                  { seconds: false },
                              )
                            : ''
                    }}

                    <UBadge v-if="entry.entry.startTime !== undefined" color="green">
                        {{ $t('common.active') }}
                    </UBadge>
                </div>
            </template>
        </UTable>

        <Pagination v-model="page" :pagination="data?.pagination" />
    </template>

    <UAccordion v-if="data && data.stats" :items="[{ slot: 'stats', label: $t('common.stats') }]" class="px-3 py-0.5">
        <template #stats>
            <TimeclockStatsBlock
                :stats="data.stats"
                :weekly="data.weekly"
                :hide-header="true"
                :failed="error !== null"
                :loading="loading"
            />
        </template>
    </UAccordion>
</template>
